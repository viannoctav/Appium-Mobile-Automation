/**
 * Webview-related helper functions
 * @module
 */
import type { WebviewsMapping } from '../commands/types';
import type { GetWebviewsOpts, WebViewDetails } from './types';
import type { ADB } from 'appium-adb';
declare const NATIVE_WIN = "NATIVE_APP";
declare const WEBVIEW_WIN = "WEBVIEW";
declare const CHROMIUM_WIN = "CHROMIUM";
declare const WEBVIEW_BASE = "WEBVIEW_";
export declare const DEVTOOLS_SOCKET_PATTERN: RegExp;
declare const KNOWN_CHROME_PACKAGE_NAMES: string[];
interface WebviewHelpers {
    /**
     * Take a webview name like WEBVIEW_4296 and use 'adb shell ps' to figure out
     * which app package is associated with that webview. One of the reasons we
     * want to do this is to make sure we're listing webviews for the actual AUT,
     * not some other running app
     *
     * @param adb - an ADB instance
     * @param webview - a webview process name
     *
     * @returns {Promise<string>} - the package name of the app running the webview
     * @throws {Error} If there was a failure while retrieving the process name
     */
    procFromWebview: (adb: ADB, webview: string) => Promise<string>;
    /**
     * Parse webview names for getContexts
     *
     * @param webviewsMapping See note on getWebViewsMapping
     * @param opts See note on getWebViewsMapping
     * @returns a list of webview names
     */
    parseWebviewNames: (webviewsMapping: WebviewsMapping[], opts?: GetWebviewsOpts) => string[];
    /**
     * Get a list of available webviews mapping by introspecting processes with adb,
     * where webviews are listed. It's possible to pass in a 'deviceSocket' arg, which
     * limits the webview possibilities to the one running on the Chromium devtools
     * socket we're interested in (see note on webviewsFromProcs). We can also
     * direct this method to verify whether a particular webview process actually
     * has any pages (if a process exists but no pages are found, Chromedriver will
     * not actually be able to connect to it, so this serves as a guard for that
     * strange failure mode). The strategy for checking whether any pages are
     * active involves sending a request to the remote debug server on the device,
     * hence it is also possible to specify the port on the host machine which
     * should be used for this communication.
     *
     * @param adb - an ADB instance
     */
    getWebViewsMapping: (adb: ADB, opts?: GetWebviewsOpts) => Promise<WebviewsMapping[]>;
    /**
     * Retrieves web view details previously cached by `getWebviews` call
     *
     * @param adb ADB instance
     * @param webview The name of the web view
     * @returns Either `undefined` or the recent web view details
     */
    getWebviewDetails: (adb: ADB, webview: string) => WebViewDetails | undefined;
    /**
     * Create Chrome driver capabilities based on the provided
     * Appium capabilities
     *
     * @param opts User-provided capabilities object
     * @param deviceId The identifier of the Android device under test
     * @returns The capabilities object.
     * @see {@link https://chromedriver.chromium.org/capabilities Chromedriver docs} for more details
     */
    createChromedriverCaps: (opts: any, deviceId: string, webViewDetails?: WebViewDetails | null) => object;
}
declare const WebviewHelpers: WebviewHelpers;
export { CHROMIUM_WIN, KNOWN_CHROME_PACKAGE_NAMES, NATIVE_WIN, WEBVIEW_BASE, WEBVIEW_WIN };
export default WebviewHelpers;
//# sourceMappingURL=webview.d.ts.map