"use strict";
/**
 * Webview-related helper functions
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WEBVIEW_WIN = exports.WEBVIEW_BASE = exports.NATIVE_WIN = exports.KNOWN_CHROME_PACKAGE_NAMES = exports.CHROMIUM_WIN = exports.DEVTOOLS_SOCKET_PATTERN = void 0;
const support_1 = require("@appium/support");
const axios_1 = __importDefault(require("axios"));
const bluebird_1 = __importDefault(require("bluebird"));
const lodash_1 = __importDefault(require("lodash"));
const lru_cache_1 = require("lru-cache");
const node_os_1 = __importDefault(require("node:os"));
const node_path_1 = __importDefault(require("node:path"));
const portscanner_1 = require("portscanner");
const logger_1 = __importDefault(require("../logger"));
const NATIVE_WIN = 'NATIVE_APP';
exports.NATIVE_WIN = NATIVE_WIN;
const WEBVIEW_WIN = 'WEBVIEW';
exports.WEBVIEW_WIN = WEBVIEW_WIN;
const CHROMIUM_WIN = 'CHROMIUM';
exports.CHROMIUM_WIN = CHROMIUM_WIN;
const WEBVIEW_BASE = `${WEBVIEW_WIN}_`;
exports.WEBVIEW_BASE = WEBVIEW_BASE;
const WEBVIEW_PID_PATTERN = new RegExp(`^${WEBVIEW_BASE}(\\d+)`);
const WEBVIEW_PKG_PATTERN = new RegExp(`^${WEBVIEW_BASE}([^\\d\\s][\\w.]*)`);
exports.DEVTOOLS_SOCKET_PATTERN = /@[\w.]+_devtools_remote_?([\w.]+_)?(\d+)?\b/;
const CROSSWALK_SOCKET_PATTERN = /@([\w.]+)_devtools_remote\b/;
const CHROMIUM_DEVTOOLS_SOCKET = 'chrome_devtools_remote';
const CHROME_PACKAGE_NAME = 'com.android.chrome';
const KNOWN_CHROME_PACKAGE_NAMES = [
    CHROME_PACKAGE_NAME,
    'com.chrome.beta',
    'com.chrome.dev',
    'com.chrome.canary',
];
exports.KNOWN_CHROME_PACKAGE_NAMES = KNOWN_CHROME_PACKAGE_NAMES;
const DEVTOOLS_PORTS_RANGE = [10900, 11000];
const WEBVIEWS_DETAILS_CACHE = new lru_cache_1.LRUCache({
    max: 100,
    updateAgeOnGet: true,
});
const CDP_REQ_TIMEOUT = 2000; // ms
const DEVTOOLS_PORT_ALLOCATION_GUARD = support_1.util.getLockFileGuard(node_path_1.default.resolve(node_os_1.default.tmpdir(), 'android_devtools_port_guard'), { timeout: 7, tryRecovery: true });
function toDetailsCacheKey(adb, webview) {
    return `${adb?.curDeviceId}:${webview}`;
}
/**
 * This function gets a list of android system processes and returns ones
 * that look like webviews
 * See https://cs.chromium.org/chromium/src/chrome/browser/devtools/device/android_device_info_query.cc
 * for more details
 *
 * @param adb - an ADB instance
 *
 * @returns a list of matching webview socket names (including the leading '@')
 */
async function getPotentialWebviewProcs(adb) {
    const out = (await adb.shell(['cat', '/proc/net/unix']));
    const names = [];
    const allMatches = [];
    for (const line of out.split('\n')) {
        // Num RefCount Protocol Flags Type St Inode Path
        const [, , , flags, , st, , sockPath] = line.trim().split(/\s+/);
        if (!sockPath) {
            continue;
        }
        if (sockPath.startsWith('@')) {
            allMatches.push(line.trim());
        }
        if (flags !== '00010000' || st !== '01') {
            continue;
        }
        if (!exports.DEVTOOLS_SOCKET_PATTERN.test(sockPath)) {
            continue;
        }
        names.push(sockPath);
    }
    if (lodash_1.default.isEmpty(names)) {
        logger_1.default.debug('Found no active devtools sockets');
        if (!lodash_1.default.isEmpty(allMatches)) {
            logger_1.default.debug(`Other sockets are: ${JSON.stringify(allMatches, null, 2)}`);
        }
    }
    else {
        logger_1.default.debug(`Parsed ${names.length} active devtools ${support_1.util.pluralize('socket', names.length, false)}: ` +
            JSON.stringify(names));
    }
    // sometimes the webview process shows up multiple times per app
    return lodash_1.default.uniq(names);
}
/**
 * This function retrieves a list of system processes that look like webviews,
 * and returns them along with the webview context name appropriate for it.
 * If we pass in a deviceSocket, we only attempt to find webviews which match
 * that socket name (this is for apps which embed Chromium, which isn't the
 * same as chrome-backed webviews).
 *
 * @param adb - an ADB instance
 * @param deviceSocket - the explictly-named device socket to use
 */
async function webviewsFromProcs(adb, deviceSocket = null) {
    const socketNames = await getPotentialWebviewProcs(adb);
    const webviews = [];
    for (const socketName of socketNames) {
        if (deviceSocket === CHROMIUM_DEVTOOLS_SOCKET && socketName === `@${deviceSocket}`) {
            webviews.push({
                proc: socketName,
                webview: CHROMIUM_WIN,
            });
            continue;
        }
        const socketNameMatch = exports.DEVTOOLS_SOCKET_PATTERN.exec(socketName);
        if (!socketNameMatch) {
            continue;
        }
        const matchedSocketName = socketNameMatch[2];
        const crosswalkMatch = CROSSWALK_SOCKET_PATTERN.exec(socketName);
        if (!matchedSocketName && !crosswalkMatch) {
            continue;
        }
        if ((deviceSocket && socketName === `@${deviceSocket}`) || !deviceSocket) {
            webviews.push({
                proc: socketName,
                webview: matchedSocketName
                    ? `${WEBVIEW_BASE}${matchedSocketName}`
                    : // @ts-expect-error: XXX crosswalkMatch can absolutely be null
                        `${WEBVIEW_BASE}${crosswalkMatch[1]}`,
            });
        }
    }
    return webviews;
}
/**
 * Allocates a local port for devtools communication
 *
 * @param adb - ADB instance
 * @param socketName - The remote Unix socket name
 * @param webviewDevtoolsPort - The local port number or null to apply
 * autodetection
 * @returns The local port number if the remote socket has been forwarded
 * successfully or `null` otherwise
 * @throws {Error} If there was an error while allocating the local port
 */
async function allocateDevtoolsPort(adb, socketName, webviewDevtoolsPort = null) {
    // socket names come with '@', but this should not be a part of the abstract
    // remote port, so remove it
    const remotePort = socketName.replace(/^@/, '');
    let [startPort, endPort] = DEVTOOLS_PORTS_RANGE;
    if (webviewDevtoolsPort) {
        endPort = webviewDevtoolsPort + (endPort - startPort);
        startPort = webviewDevtoolsPort;
    }
    logger_1.default.debug(`Forwarding remote port ${remotePort} to a local ` + `port in range ${startPort}..${endPort}`);
    if (!webviewDevtoolsPort) {
        logger_1.default.debug(`You could use the 'webviewDevtoolsPort' capability to customize ` +
            `the starting port number`);
    }
    return (await DEVTOOLS_PORT_ALLOCATION_GUARD(async () => {
        let localPort;
        try {
            localPort = await (0, portscanner_1.findAPortNotInUse)(startPort, endPort);
        }
        catch (e) {
            throw new Error(`Cannot find any free port to forward the Devtools socket ` +
                `in range ${startPort}..${endPort}. You could set the starting port number ` +
                `manually by providing the 'webviewDevtoolsPort' capability`);
        }
        await adb.adbExec(['forward', `tcp:${localPort}`, `localabstract:${remotePort}`]);
        return localPort;
    }));
}
/**
 * This is a wrapper for Chrome Debugger Protocol data collection.
 * No error is thrown if CDP request fails - in such case no data will be
 * recorded into the corresponding `webviewsMapping` item.
 *
 * @param adb The ADB instance
 * @param webviewsMapping The current webviews mapping
 * !!! Each item of this array gets mutated (`info`/`pages` properties get added
 * based on the provided `opts`) if the requested details have been
 * successfully retrieved for it !!!
 * @param opts If both `ensureWebviewsHavePages` and
 * `enableWebviewDetailsCollection` properties are falsy then no details collection
 * is performed
 */
async function collectWebviewsDetails(adb, webviewsMapping, opts = {}) {
    if (lodash_1.default.isEmpty(webviewsMapping)) {
        return;
    }
    const { webviewDevtoolsPort = null, ensureWebviewsHavePages = null, enableWebviewDetailsCollection = null, } = opts;
    if (!ensureWebviewsHavePages) {
        logger_1.default.info(`Not checking whether webviews have active pages; use the ` +
            `'ensureWebviewsHavePages' cap to turn this check on`);
    }
    if (!enableWebviewDetailsCollection) {
        logger_1.default.info(`Not collecting web view details. Details collection might help ` +
            `to make Chromedriver initialization more precise. Use the 'enableWebviewDetailsCollection' ` +
            `cap to turn it on`);
    }
    if (!ensureWebviewsHavePages && !enableWebviewDetailsCollection) {
        return;
    }
    // Connect to each devtools socket and retrieve web view details
    logger_1.default.debug(`Collecting CDP data of ${support_1.util.pluralize('webview', webviewsMapping.length, true)}`);
    const detailCollectors = [];
    for (const item of webviewsMapping) {
        detailCollectors.push((async () => {
            let localPort;
            try {
                localPort = await allocateDevtoolsPort(adb, item.proc, webviewDevtoolsPort);
                if (enableWebviewDetailsCollection) {
                    item.info = await cdpInfo(localPort);
                }
                if (ensureWebviewsHavePages) {
                    item.pages = await cdpList(localPort);
                }
            }
            catch (e) {
                logger_1.default.debug(e);
            }
            finally {
                if (localPort) {
                    try {
                        await adb.removePortForward(localPort);
                    }
                    catch (e) {
                        logger_1.default.debug(e);
                    }
                }
            }
        })());
    }
    await bluebird_1.default.all(detailCollectors);
    logger_1.default.debug(`CDP data collection completed`);
}
// https://chromedevtools.github.io/devtools-protocol/
async function cdpList(localPort) {
    return (await (0, axios_1.default)({
        url: `http://127.0.0.1:${localPort}/json/list`,
        timeout: CDP_REQ_TIMEOUT,
    })).data;
}
// https://chromedevtools.github.io/devtools-protocol/
async function cdpInfo(localPort) {
    return (await (0, axios_1.default)({
        url: `http://127.0.0.1:${localPort}/json/version`,
        timeout: CDP_REQ_TIMEOUT,
    })).data;
}
const WebviewHelpers = {
    async procFromWebview(adb, webview) {
        const pidMatch = WEBVIEW_PID_PATTERN.exec(webview);
        if (!pidMatch) {
            throw new Error(`Could not find PID for webview '${webview}'`);
        }
        const pid = pidMatch[1];
        logger_1.default.debug(`${webview} mapped to pid ${pid}`);
        logger_1.default.debug(`Getting process name for webview '${webview}'`);
        const pkg = await adb.getNameByPid(pid);
        logger_1.default.debug(`Got process name: '${pkg}'`);
        return pkg;
    },
    parseWebviewNames(webviewsMapping, { ensureWebviewsHavePages = true, isChromeSession = false } = {}) {
        if (isChromeSession) {
            return [CHROMIUM_WIN];
        }
        const result = [];
        for (const { webview, pages, proc, webviewName } of webviewsMapping) {
            if (ensureWebviewsHavePages && pages?.length === 0) {
                logger_1.default.info(`Skipping the webview '${webview}' at '${proc}' ` +
                    `since it has reported having zero pages`);
                continue;
            }
            if (webviewName) {
                result.push(webviewName);
            }
        }
        logger_1.default.debug(`Found ${support_1.util.pluralize('webview', result.length, true)}: ${JSON.stringify(result)}`);
        return result;
    },
    async getWebViewsMapping(adb, { androidDeviceSocket = null, ensureWebviewsHavePages = true, webviewDevtoolsPort = null, enableWebviewDetailsCollection = true, } = {}) {
        logger_1.default.debug('Getting a list of available webviews');
        const webviewsMapping = (await webviewsFromProcs(adb, androidDeviceSocket));
        await collectWebviewsDetails(adb, webviewsMapping, {
            ensureWebviewsHavePages,
            enableWebviewDetailsCollection,
            webviewDevtoolsPort,
        });
        for (const webviewMapping of webviewsMapping) {
            const { webview, info } = webviewMapping;
            webviewMapping.webviewName = null;
            let wvName = webview;
            let process;
            if (!androidDeviceSocket) {
                const pkgMatch = WEBVIEW_PKG_PATTERN.exec(webview);
                try {
                    // web view name could either be suffixed with PID or the package name
                    // package names could not start with a digit
                    const pkg = pkgMatch ? pkgMatch[1] : await WebviewHelpers.procFromWebview(adb, webview);
                    wvName = `${WEBVIEW_BASE}${pkg}`;
                    const pidMatch = WEBVIEW_PID_PATTERN.exec(webview);
                    process = {
                        name: pkg,
                        id: pidMatch ? pidMatch[1] : null,
                    };
                }
                catch (e) {
                    logger_1.default.warn(e.message);
                    continue;
                }
            }
            webviewMapping.webviewName = wvName;
            const key = toDetailsCacheKey(adb, wvName);
            if (info || process) {
                WEBVIEWS_DETAILS_CACHE.set(key, { info, process });
            }
            else if (WEBVIEWS_DETAILS_CACHE.has(key)) {
                WEBVIEWS_DETAILS_CACHE.delete(key);
            }
        }
        return webviewsMapping;
    },
    getWebviewDetails(adb, webview) {
        const key = toDetailsCacheKey(adb, webview);
        return WEBVIEWS_DETAILS_CACHE.get(key);
    },
    createChromedriverCaps(opts, deviceId, webViewDetails) {
        const caps = { chromeOptions: {} };
        const androidPackage = opts.chromeOptions?.androidPackage ||
            opts.appPackage ||
            webViewDetails?.info?.['Android-Package'];
        if (androidPackage) {
            // chromedriver raises an invalid argument error when androidPackage is 'null'
            caps.chromeOptions.androidPackage = androidPackage;
        }
        if (lodash_1.default.isBoolean(opts.chromeUseRunningApp)) {
            caps.chromeOptions.androidUseRunningApp = opts.chromeUseRunningApp;
        }
        if (opts.chromeAndroidPackage) {
            caps.chromeOptions.androidPackage = opts.chromeAndroidPackage;
        }
        if (opts.chromeAndroidActivity) {
            caps.chromeOptions.androidActivity = opts.chromeAndroidActivity;
        }
        if (opts.chromeAndroidProcess) {
            caps.chromeOptions.androidProcess = opts.chromeAndroidProcess;
        }
        else if (webViewDetails?.process?.name && webViewDetails?.process?.id) {
            caps.chromeOptions.androidProcess = webViewDetails.process.name;
        }
        if (lodash_1.default.toLower(opts.browserName) === 'chromium-webview') {
            caps.chromeOptions.androidActivity = opts.appActivity;
        }
        if (opts.pageLoadStrategy) {
            caps.pageLoadStrategy = opts.pageLoadStrategy;
        }
        const isChrome = lodash_1.default.toLower(caps.chromeOptions.androidPackage) === 'chrome';
        if (lodash_1.default.includes(KNOWN_CHROME_PACKAGE_NAMES, caps.chromeOptions.androidPackage) || isChrome) {
            // if we have extracted package from context name, it could come in as bare
            // "chrome", and so we should make sure the details are correct, including
            // not using an activity or process id
            if (isChrome) {
                caps.chromeOptions.androidPackage = CHROME_PACKAGE_NAME;
            }
            delete caps.chromeOptions.androidActivity;
            delete caps.chromeOptions.androidProcess;
        }
        // add device id from adb
        caps.chromeOptions.androidDeviceSerial = deviceId;
        if (lodash_1.default.isPlainObject(opts.loggingPrefs) || lodash_1.default.isPlainObject(opts.chromeLoggingPrefs)) {
            if (opts.loggingPrefs) {
                logger_1.default.warn(`The 'loggingPrefs' cap is deprecated; use the 'chromeLoggingPrefs' cap instead`);
            }
            // @ts-expect-error Why are we using this if it's deprecated?
            caps.loggingPrefs = opts.chromeLoggingPrefs || opts.loggingPrefs;
        }
        if (opts.enablePerformanceLogging) {
            logger_1.default.warn(`The 'enablePerformanceLogging' cap is deprecated; simply use ` +
                `the 'chromeLoggingPrefs' cap instead, with a 'performance' key set to 'ALL'`);
            const newPref = { performance: 'ALL' };
            // don't overwrite other logging prefs that have been sent in if they exist
            // @ts-expect-error Why are we using this if it's deprecated?
            caps.loggingPrefs = caps.loggingPrefs
                ? // @ts-expect-error Why are we using this if it's deprecated?
                    Object.assign({}, caps.loggingPrefs, newPref)
                : newPref;
        }
        if (opts.chromeOptions?.Arguments) {
            // merge `Arguments` and `args`
            opts.chromeOptions.args = [
                ...(opts.chromeOptions.args || []),
                ...opts.chromeOptions.Arguments,
            ];
            delete opts.chromeOptions.Arguments;
        }
        logger_1.default.debug('Precalculated Chromedriver capabilities: ' + JSON.stringify(caps.chromeOptions, null, 2));
        const protectedCapNames = [];
        for (const [opt, val] of lodash_1.default.toPairs(opts.chromeOptions)) {
            if (lodash_1.default.isUndefined(caps.chromeOptions[opt])) {
                caps.chromeOptions[opt] = val;
            }
            else {
                protectedCapNames.push(opt);
            }
        }
        if (!lodash_1.default.isEmpty(protectedCapNames)) {
            logger_1.default.info('The following Chromedriver capabilities cannot be overridden ' +
                'by the provided chromeOptions:');
            for (const optName of protectedCapNames) {
                logger_1.default.info(`  ${optName} (${JSON.stringify(opts.chromeOptions[optName])})`);
            }
        }
        return caps;
    },
};
exports.default = WebviewHelpers;
//# sourceMappingURL=webview.js.map