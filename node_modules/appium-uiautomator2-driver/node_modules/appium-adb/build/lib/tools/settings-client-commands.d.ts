export default commands;
export type SettingsAppStartupOptions = {
    /**
     * The maximum number of milliseconds
     * to wait until the app has started
     */
    timeout?: number | undefined;
    /**
     * Whether to restore
     * the activity which was the current one before Settings startup
     */
    shouldRestoreCurrentApp?: boolean | undefined;
};
export type Location = {
    /**
     * - Valid longitude value.
     */
    longitude: number | string;
    /**
     * - Valid latitude value.
     */
    latitude: number | string;
    /**
     * - Valid altitude value.
     */
    altitude?: string | number | null | undefined;
    /**
     * - Number of satellites being tracked (1-12).
     * This value is ignored on real devices.
     */
    satellites?: string | number | null | undefined;
    /**
     * - Valid speed value.
     * Should be greater than 0.0 meters/second for real devices or 0.0 knots
     * for emulators.
     */
    speed?: string | number | null | undefined;
};
export type SmsListOptions = {
    /**
     * - The maximum count of recent messages
     * to retrieve
     */
    max?: number | undefined;
};
export type SmsListResult = {
    items: SmsListResultItem[];
    total: number;
};
export type SmsListResultItem = {
    id: string;
    address: string;
    person: string | null;
    date: string;
    read: string;
    status: string;
    type: string;
    subject: string | null;
    body: string;
    serviceCenter: string | null;
};
export type SettingsClientCommands = typeof commands;
declare namespace commands {
    /**
     * @typedef {Object} SettingsAppStartupOptions
     * @property {number} [timeout=5000] The maximum number of milliseconds
     * to wait until the app has started
     * @property {boolean} [shouldRestoreCurrentApp=false] Whether to restore
     * the activity which was the current one before Settings startup
     */
    /**
     * Ensures that Appium Settings helper application is running
     * and starts it if necessary
     *
     * @this {import('../adb.js').ADB}
     * @param {SettingsAppStartupOptions} [opts={}]
     * @throws {Error} If Appium Settings has failed to start
     * @returns {Promise<import('../adb.js').ADB>} self instance for chaining
     */
    function requireRunningSettingsApp(this: import("../adb.js").ADB, opts?: SettingsAppStartupOptions | undefined): Promise<import("../adb.js").ADB>;
    /**
     * Change the state of WiFi on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} on - True to enable and false to disable it.
     * @param {boolean} [isEmulator=false] - Set it to true if the device under test
     *                                       is an emulator rather than a real device.
     */
    function setWifiState(this: import("../adb.js").ADB, on: boolean, isEmulator?: boolean | undefined): Promise<void>;
    /**
     * Change the state of Data transfer on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} on - True to enable and false to disable it.
     * @param {boolean} [isEmulator=false] - Set it to true if the device under test
     *                                       is an emulator rather than a real device.
     */
    function setDataState(this: import("../adb.js").ADB, on: boolean, isEmulator?: boolean | undefined): Promise<void>;
    /**
     * Change the state of animation on the device under test.
     * Animation on the device is controlled by the following global properties:
     * [ANIMATOR_DURATION_SCALE]{@link https://developer.android.com/reference/android/provider/Settings.Global.html#ANIMATOR_DURATION_SCALE},
     * [TRANSITION_ANIMATION_SCALE]{@link https://developer.android.com/reference/android/provider/Settings.Global.html#TRANSITION_ANIMATION_SCALE},
     * [WINDOW_ANIMATION_SCALE]{@link https://developer.android.com/reference/android/provider/Settings.Global.html#WINDOW_ANIMATION_SCALE}.
     * This method sets all this properties to 0.0 to disable (1.0 to enable) animation.
     *
     * Turning off animation might be useful to improve stability
     * and reduce tests execution time.
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} on - True to enable and false to disable it.
     */
    function setAnimationState(this: import("../adb.js").ADB, on: boolean): Promise<void>;
    /**
     * Change the locale on the device under test. Don't need to reboot the device after changing the locale.
     * This method sets an arbitrary locale following:
     *   https://developer.android.com/reference/java/util/Locale.html
     *   https://developer.android.com/reference/java/util/Locale.html#Locale(java.lang.String,%20java.lang.String)
     *
     * @this {import('../adb.js').ADB}
     * @param {string} language - Language. e.g. en, ja
     * @param {string} country - Country. e.g. US, JP
     * @param {string?} [script=null] - Script. e.g. Hans in `zh-Hans-CN`
     */
    function setDeviceSysLocaleViaSettingApp(this: import("../adb.js").ADB, language: string, country: string, script?: string | null | undefined): Promise<void>;
    /**
     * @typedef {Object} Location
     * @property {number|string} longitude - Valid longitude value.
     * @property {number|string} latitude - Valid latitude value.
     * @property {?number|string} [altitude] - Valid altitude value.
     * @property {?number|string} [satellites=12] - Number of satellites being tracked (1-12).
     * This value is ignored on real devices.
     * @property {?number|string} [speed] - Valid speed value.
     * Should be greater than 0.0 meters/second for real devices or 0.0 knots
     * for emulators.
     */
    /**
     * Emulate geolocation coordinates on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {Location} location - Location object. The `altitude` value is ignored
     * while mocking the position.
     * @param {boolean} [isEmulator=false] - Set it to true if the device under test
     *                                       is an emulator rather than a real device.
     */
    function setGeoLocation(this: import("../adb.js").ADB, location: Location, isEmulator?: boolean | undefined): Promise<void>;
    /**
     * Get the current cached GPS location from the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<Location>} The current location
     * @throws {Error} If the current location cannot be retrieved
     */
    function getGeoLocation(this: import("../adb.js").ADB): Promise<Location>;
    /**
     * Sends an async request to refresh the GPS cache.
     * This feature only works if the device under test has
     * Google Play Services installed. In case the vanilla
     * LocationManager is used the device API level must be at
     * version 30 (Android R) or higher.
     *
     * @this {import('../adb.js').ADB}
     * @param {number} timeoutMs The maximum number of milliseconds
     * to block until GPS cache is refreshed. Providing zero or a negative
     * value to it skips waiting completely.
     *
     * @throws {Error} If the GPS cache cannot be refreshed.
     */
    function refreshGeoLocationCache(this: import("../adb.js").ADB, timeoutMs?: number): Promise<void>;
    /**
     * Performs the given editor action on the focused input field.
     * This method requires Appium Settings helper to be installed on the device.
     * No exception is thrown if there was a failure while performing the action.
     * You must investigate the logcat output if something did not work as expected.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} action - Either action code or name. The following action
     *                                 names are supported: `normal, unspecified, none,
     *                                 go, search, send, next, done, previous`
     */
    function performEditorAction(this: import("../adb.js").ADB, action: string | number): Promise<void>;
    /**
     * Retrieves the text content of the device's clipboard.
     * The method works for Android below and above 29.
     * It temorarily enforces the IME setting in order to workaround
     * security limitations if needed.
     * This method only works if Appium Settings v. 2.15+ is installed
     * on the device under test
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<string>} The actual content of the main clipboard as
     * base64-encoded string or an empty string if the clipboard is empty
     * @throws {Error} If there was a problem while getting the
     * clipboard contant
     */
    function getClipboard(this: import("../adb.js").ADB): Promise<string>;
    /**
     * Retrieves Android notifications via Appium Settings helper.
     * Appium Settings app itself must be *manually* granted to access notifications
     * under device Settings in order to make this feature working.
     * Appium Settings helper keeps all the active notifications plus
     * notifications that appeared while it was running in the internal buffer,
     * but no more than 100 items altogether. Newly appeared notifications
     * are always added to the head of the notifications array.
     * The `isRemoved` flag is set to `true` for notifications that have been removed.
     *
     * See https://developer.android.com/reference/android/service/notification/StatusBarNotification
     * and https://developer.android.com/reference/android/app/Notification.html
     * for more information on available notification properties and their values.
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<import('@appium/types').StringRecord>} The example output is:
     * ```json
     * {
     *   "statusBarNotifications":[
     *     {
     *       "isGroup":false,
     *       "packageName":"io.appium.settings",
     *       "isClearable":false,
     *       "isOngoing":true,
     *       "id":1,
     *       "tag":null,
     *       "notification":{
     *         "title":null,
     *         "bigTitle":"Appium Settings",
     *         "text":null,
     *         "bigText":"Keep this service running, so Appium for Android can properly interact with several system APIs",
     *         "tickerText":null,
     *         "subText":null,
     *         "infoText":null,
     *         "template":"android.app.Notification$BigTextStyle"
     *       },
     *       "userHandle":0,
     *       "groupKey":"0|io.appium.settings|1|null|10133",
     *       "overrideGroupKey":null,
     *       "postTime":1576853518850,
     *       "key":"0|io.appium.settings|1|null|10133",
     *       "isRemoved":false
     *     }
     *   ]
     * }
     * ```
     * @throws {Error} If there was an error while getting the notifications list
     */
    function getNotifications(this: import("../adb.js").ADB): Promise<import("@appium/types").StringRecord<any>>;
    /**
     * @typedef {Object} SmsListOptions
     * @property {number} [max=100] - The maximum count of recent messages
     * to retrieve
     */
    /**
     * @typedef SmsListResult
     * @property {SmsListResultItem[]} items
     * @property {number} total
     */
    /**
     * @privateRemarks XXX: WAG
     * @typedef SmsListResultItem
     * @property {string} id
     * @property {string} address
     * @property {string|null} person
     * @property {string} date
     * @property {string} read
     * @property {string} status
     * @property {string} type
     * @property {string|null} subject
     * @property {string} body
     * @property {string|null} serviceCenter
     */
    /**
     * Retrieves the list of the most recent SMS
     * properties list via Appium Settings helper.
     * Messages are sorted by date in descending order.
     *
     * @this {import('../adb.js').ADB}
     * @param {SmsListOptions} opts
     * @returns {Promise<SmsListResult>} The example output is:
     * ```json
     * {
     *   "items":[
     *     {
     *       "id":"2",
     *       "address":"+123456789",
     *       "person":null,
     *       "date":"1581936422203",
     *       "read":"0",
     *       "status":"-1",
     *       "type":"1",
     *       "subject":null,
     *       "body":"\"text message2\"",
     *       "serviceCenter":null
     *     },
     *     {
     *       "id":"1",
     *       "address":"+123456789",
     *       "person":null,
     *       "date":"1581936382740",
     *       "read":"0",
     *       "status":"-1",
     *       "type":"1",
     *       "subject":null,
     *       "body":"\"text message\"",
     *       "serviceCenter":null
     *     }
     *   ],
     *   "total":2
     * }
     * ```
     * @throws {Error} If there was an error while getting the SMS list
     */
    function getSmsList(this: import("../adb.js").ADB, opts?: SmsListOptions): Promise<SmsListResult>;
    /**
     * Types the given Unicode string.
     * It is expected that the focus is already put
     * to the destination input field before this method is called.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} text The string to type
     * @returns {Promise<boolean>} `true` if the input text has been successfully sent to adb
     */
    function typeUnicode(this: import("../adb.js").ADB, text: string): Promise<boolean>;
    /**
     * Performs recursive media scan at the given destination.
     * All successfully scanned items are being added to the device's
     * media library.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} destination File/folder path on the remote device.
     * @throws {Error} If there was an unexpected error by scanning.
     */
    function scanMedia(this: import("../adb.js").ADB, destination: string): Promise<void>;
}
//# sourceMappingURL=settings-client-commands.d.ts.map